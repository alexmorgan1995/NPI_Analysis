if(time >= timeequal) { # if time is equal
beta <- beta(time,tstart1, R0)*(1-(1*efficacy))
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, beta*I*S*N ,beta,  (beta*I*S*N)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
} else{ #if inc is over 1000
beta <- beta(time,tstart1, R0)*(1-(inc_cont[nrow(inc_cont),3]/(inc_cont[nrow(inc_cont),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#### Big Function ####
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
contact_trac_run <- function(efficacy, ramp_rate, R0, target) {
#Parameters
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
parms = c(gamma = 1/(GenTime(3.3,2.8)),
zeta = 1/365,
tstart1 = 71,
N = 5.5*10^6,
efficacy = efficacy,
ramp_rate = ramp_rate,
R0 = R0,
target = target)
#Baseline
times <- seq(0, 478, by = 1)
inc_cont <<- data.frame(0, 0)
out1 <- data.frame(rk(y = init, func = SIRS1, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0), ]
timecomp <<- inc_cont[,1][which(abs((inc_cont[,2]*N - 1000) - 0) == min(abs((inc_cont[,2]*N - 1000) - 0)) & inc_cont[,1] > parms["tstart1"])]
#Intersect
inc_cont1 <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 300, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS2, times = times, parms = parms, method = "rk2"))
inc_cont1 <<- inc_cont1[!duplicated(inc_cont1$X0),]
t <- inc_cont1[,1][which(inc_cont1[,5] < 1 & inc_cont1[,5] > 0)]
t1 <- split(t, cumsum(c(1, diff(t) != 1)))[[1]]
timeequal <<- t1[length(t1)]
#Actually Run the Model
inc_cont <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 600, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS3, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0),]
inc_cont[1,1] <<- 0; inc_cont[1,2] <<- 0
colnames(inc_cont) <<- c("time", "incidence", "contacttraccap", "beta", "con/inc rat")
time10 <- inc_cont[,1][which(inc_cont[,2] < target)][2]
timesince <- inc_cont[,1][which(inc_cont[,2] < target)][2] - timecomp
return(c("Time1000" = timeequal, "TimeContactTracEqualInc" = timecomp,"TimeTargetReach" = time10, "RelTimetoTarget" = timesince))
}
#Specify the efficacy (as a fraction), ramp_rate, lockdown R0 and target incidence
#inc_cont will always output during the run - view for a more detailed overview of the model run.
contact_trac_run(0.8, 50, 0.9, 10)
#### Heat Maps ####
expand.grid(seq(),seq())
setwd("C:/Users/amorg/Documents/PhD/nCoV Work/Models/ContactTracing")
rm(list=ls())
library("deSolve"); library("ggplot2"); library("ggpubr"); library("reshape2"); library("Cairo")
#### Model Functions - Gen Time/ Betas/ODEs ####
#Generation Time
GenTime <- function(T2, R0) {
G = T2 * ((R0-1)/log(2))
return(G)
}
#Model Betas
beta <- function(time, tstart1, R0) {
gamma <- 1/(GenTime(3.3,2.8))
ifelse((time >= tstart1 & time <= Inf),
R0*gamma, #Phase 2 - Before this was R0 = 0.9
1.7*gamma #Phase 1
)
}
#Baseline SIRS To identify time at inc = 1000
SIRS1 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inc_tim_inc <- c(time+1, beta*I*S)
inc_cont <<- rbind(inc_cont, inc_tim_inc) # Tracking the daily incidence
return(list(c(dS, dI, dR)))
})
}
#Linear Increase in contact tracing
lin_cont <- function(x,m,comp) {
y = m*(x-comp+1) + 0
return(y)
}
#SIRS Model To Identify where contact tracing = incidence
SIRS2 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
timecomp = timecomp
if(time >= timecomp) {
beta <- beta(time,tstart1, R0)*(1-(inc_cont1[nrow(inc_cont1),3]/(inc_cont1[nrow(inc_cont1),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont1 <<- rbind(inc_cont1, inctime)
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont1 <<- rbind(inc_cont1, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#SIRS Model used for Final Model Output
SIRS3 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
timecomp = timecomp
timeequal = timeequal
if(time >= timecomp) {
if(time >= timeequal) { # if time is equal
beta <- beta(time,tstart1, R0)*(1-(1*efficacy))
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, beta*I*S*N ,beta,  (beta*I*S*N)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
} else{ #if inc is over 1000
beta <- beta(time,tstart1, R0)*(1-(inc_cont[nrow(inc_cont),3]/(inc_cont[nrow(inc_cont),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#### Big Function ####
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
contact_trac_run <- function(efficacy, ramp_rate, R0, target) {
#Parameters
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
parms = c(gamma = 1/(GenTime(3.3,2.8)),
zeta = 1/365,
tstart1 = 71,
N = 5.5*10^6,
efficacy = efficacy,
ramp_rate = ramp_rate,
R0 = R0,
target = target)
#Baseline
times <- seq(0, 478, by = 1)
inc_cont <<- data.frame(0, 0)
out1 <- data.frame(rk(y = init, func = SIRS1, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0), ]
timecomp <<- inc_cont[,1][which(abs((inc_cont[,2]*N - 1000) - 0) == min(abs((inc_cont[,2]*N - 1000) - 0)) & inc_cont[,1] > parms["tstart1"])]
#Intersect
inc_cont1 <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 300, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS2, times = times, parms = parms, method = "rk2"))
inc_cont1 <<- inc_cont1[!duplicated(inc_cont1$X0),]
t <- inc_cont1[,1][which(inc_cont1[,5] < 1 & inc_cont1[,5] > 0)]
t1 <- split(t, cumsum(c(1, diff(t) != 1)))[[1]]
timeequal <<- t1[length(t1)]
#Actually Run the Model
inc_cont <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 600, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS3, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0),]
inc_cont[1,1] <<- 0; inc_cont[1,2] <<- 0
colnames(inc_cont) <<- c("time", "incidence", "contacttraccap", "beta", "con/inc rat")
time10 <- inc_cont[,1][which(inc_cont[,2] < target)][2]
timesince <- inc_cont[,1][which(inc_cont[,2] < target)][2] - timecomp
return(c("Time1000" = timeequal, "TimeContactTracEqualInc" = timecomp,"TimeTargetReach" = time10, "RelTimetoTarget" = timesince))
}
#Specify the efficacy (as a fraction), ramp_rate, lockdown R0 and target incidence
#inc_cont will always output during the run - view for a more detailed overview of the model run.
contact_trac_run(0.8, 50, 0.9, 10)
#### Heat Maps ####
expand.grid(seq(),seq())
View(inc_cont1)
setwd("C:/Users/amorg/Documents/PhD/nCoV Work/Models/ContactTracing")
rm(list=ls())
library("deSolve"); library("ggplot2"); library("ggpubr"); library("reshape2"); library("Cairo")
#### Model Functions - Gen Time/ Betas/ODEs ####
#Generation Time
GenTime <- function(T2, R0) {
G = T2 * ((R0-1)/log(2))
return(G)
}
#Model Betas
beta <- function(time, tstart1, R0) {
gamma <- 1/(GenTime(3.3,2.8))
ifelse((time >= tstart1 & time <= Inf),
R0*gamma, #Phase 2 - Before this was R0 = 0.9
1.7*gamma #Phase 1
)
}
#Baseline SIRS To identify time at inc = 1000
SIRS1 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inc_tim_inc <- c(time+1, beta*I*S)
inc_cont <<- rbind(inc_cont, inc_tim_inc) # Tracking the daily incidence
return(list(c(dS, dI, dR)))
})
}
#Linear Increase in contact tracing
lin_cont <- function(x,m,comp) {
y = m*(x-comp+1) + 0
return(y)
}
#SIRS Model To Identify where contact tracing = incidence
SIRS2 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
timecomp = timecomp
if(time >= timecomp) {
beta <- beta(time,tstart1, R0)*(1-(inc_cont[nrow(inc_cont),3]/(inc_cont[nrow(inc_cont),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#SIRS Model used for Final Model Output
SIRS3 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
timecomp = timecomp
timeequal = timeequal
if(time >= timecomp) {
if(time >= timeequal) { # if time is equal
beta <- beta(time,tstart1, R0)*(1-(1*efficacy))
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, beta*I*S*N ,beta,  (beta*I*S*N)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
} else{ #if inc is over 1000
beta <- beta(time,tstart1, R0)*(1-(inc_cont[nrow(inc_cont),3]/(inc_cont[nrow(inc_cont),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#### Big Function ####
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
contact_trac_run <- function(efficacy, ramp_rate, R0, target) {
#Parameters
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
parms = c(gamma = 1/(GenTime(3.3,2.8)),
zeta = 1/365,
tstart1 = 71,
N = 5.5*10^6,
efficacy = efficacy,
ramp_rate = ramp_rate,
R0 = R0,
target = target)
#Baseline
times <- seq(0, 478, by = 1)
inc_cont <<- data.frame(0, 0)
out1 <- data.frame(rk(y = init, func = SIRS1, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0), ]
timecomp <<- inc_cont[,1][which(abs((inc_cont[,2]*N - 1000) - 0) == min(abs((inc_cont[,2]*N - 1000) - 0)) & inc_cont[,1] > parms["tstart1"])]
#Intersect
inc_cont <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 300, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS2, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0),]
t <- inc_cont[,1][which(inc_cont[,5] < 1 & inc_cont[,5] > 0)]
t1 <- split(t, cumsum(c(1, diff(t) != 1)))[[1]]
timeequal <<- t1[length(t1)]
#Actually Run the Model
inc_cont <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 600, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS3, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0),]
inc_cont[1,1] <<- 0; inc_cont[1,2] <<- 0
colnames(inc_cont) <<- c("time", "incidence", "contacttraccap", "beta", "con/inc rat")
time10 <- inc_cont[,1][which(inc_cont[,2] < target)][2]
timesince <- inc_cont[,1][which(inc_cont[,2] < target)][2] - timecomp
return(c("Time1000" = timeequal, "TimeContactTracEqualInc" = timecomp,"TimeTargetReach" = time10, "RelTimetoTarget" = timesince))
}
#Specify the efficacy (as a fraction), ramp_rate, lockdown R0 and target incidence
#inc_cont will always output during the run - view for a more detailed overview of the model run.
contact_trac_run(0.8, 50, 0.9, 10)
#### Heat Maps ####
expand.grid(seq(),seq())
expand.grid(seq(1,50),seq(0.7,1, by = 0.01))
heatmap <- expand.grid(seq(1,50),seq(0.7,1, by = 0.01))
heatdata <- data.frame(matrix(nrow = nrow(heatmap), ncol = 5))
View(heatdata)
heatmap[2,1]
heatmap[1,2]
contact_trac_run(0.8, 0, 0.9, 10)
heatdata[i,]
heatdata[1,]
heatmap <- expand.grid(seq(1,50),seq(0.7,1, by = 0.01))
heatdata <- data.frame(matrix(nrow = nrow(heatmap), ncol = 7))
for (i in 1:nrow(heatmap)) {
heatdata[i,] <- c(heatmap[i,1],heatmap[i,2],contact_trac_run(0.8, heatmap[i,1], heatmap[i,2], 10))
colnames(heatdata) <- c("ContRampUp", "Lock_R0", "Time1000", "TimeContactTracEqualInc", "TimeTargetReach", "RelTimetoTarget")
}
heatmap <- expand.grid(seq(1,50),seq(0.7,1, by = 0.01))
heatdata <- data.frame(matrix(nrow = nrow(heatmap), ncol = 6))
for (i in 1:nrow(heatmap)) {
heatdata[i,] <- c(heatmap[i,1],heatmap[i,2],contact_trac_run(0.8, heatmap[i,1], heatmap[i,2], 10))
}
colnames(heatdata) <- c("ContRampUp", "Lock_R0", "Time1000", "TimeContactTracEqualInc", "TimeTargetReach", "RelTimetoTarget")
View(heatdata)
setwd("C:/Users/amorg/Documents/PhD/nCoV Work/Models/ContactTracing")
rm(list=ls())
library("deSolve"); library("ggplot2"); library("ggpubr"); library("reshape2"); library("Cairo")
#### Model Functions - Gen Time/ Betas/ODEs ####
#Generation Time
GenTime <- function(T2, R0) {
G = T2 * ((R0-1)/log(2))
return(G)
}
#Model Betas
beta <- function(time, tstart1, R0) {
gamma <- 1/(GenTime(3.3,2.8))
ifelse((time >= tstart1 & time <= Inf),
R0*gamma, #Phase 2 - Before this was R0 = 0.9
1.7*gamma #Phase 1
)
}
#Baseline SIRS To identify time at inc = 1000
SIRS1 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inc_tim_inc <- c(time+1, beta*I*S)
inc_cont <<- rbind(inc_cont, inc_tim_inc) # Tracking the daily incidence
return(list(c(dS, dI, dR)))
})
}
#Linear Increase in contact tracing
lin_cont <- function(x,m,comp) {
y = m*(x-comp+1) + 0
return(y)
}
#SIRS Model To Identify where contact tracing = incidence
SIRS2 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
timecomp = timecomp
if(time >= timecomp) {
beta <- beta(time,tstart1, R0)*(1-(inc_cont[nrow(inc_cont),3]/(inc_cont[nrow(inc_cont),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#SIRS Model used for Final Model Output
SIRS3 <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
timecomp = timecomp
timeequal = timeequal
if(time >= timecomp) {
if(time >= timeequal) { # if time is equal
beta <- beta(time,tstart1, R0)*(1-(1*efficacy))
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, beta*I*S*N ,beta,  (beta*I*S*N)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
} else{ #if inc is over 1000
beta <- beta(time,tstart1, R0)*(1-(inc_cont[nrow(inc_cont),3]/(inc_cont[nrow(inc_cont),2]))*efficacy)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N, lin_cont(time, ramp_rate, timecomp), beta, lin_cont(time, ramp_rate, timecomp)/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
} else { #if inc < 1000
beta <- beta(time,tstart1, R0)
dS = - beta*I*S + zeta*R
dI = beta*I*S - gamma*I
dR = gamma*I - zeta*R
inctime <- c(time+1, beta*I*S*N , 0, beta, 0/ (beta*I*S*N))
inc_cont <<- rbind(inc_cont, inctime)
}
return(list(c(dS, dI, dR)))
})
}
#### Big Function ####
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
contact_trac_run <- function(efficacy, ramp_rate, R0, target) {
#Parameters
N <- 5.5*10^6
init <- c(S = (N-(N*0.0001))/N, I = (N*0.0001)/N, R= 0)
parms = c(gamma = 1/(GenTime(3.3,2.8)),
zeta = 1/365,
tstart1 = 71,
N = 5.5*10^6,
efficacy = efficacy,
ramp_rate = ramp_rate,
R0 = R0,
target = target)
#Baseline
times <- seq(0, 478, by = 1)
inc_cont <<- data.frame(0, 0)
out1 <- data.frame(rk(y = init, func = SIRS1, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0), ]
timecomp <<- inc_cont[,1][which(abs((inc_cont[,2]*N - 1000) - 0) == min(abs((inc_cont[,2]*N - 1000) - 0)) & inc_cont[,1] > parms["tstart1"])]
#Intersect
inc_cont <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 300, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS2, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0),]
t <- inc_cont[,1][which(inc_cont[,5] < 1 & inc_cont[,5] > 0)]
t1 <- split(t, cumsum(c(1, diff(t) != 1)))[[1]]
timeequal <<- t1[length(t1)]
#Actually Run the Model
inc_cont <<- data.frame(0, 0, 0, 0, 0)
times <- seq(0, 600, by = 1)
out1 <- data.frame(rk(y = init, func = SIRS3, times = times, parms = parms, method = "rk2"))
inc_cont <<- inc_cont[!duplicated(inc_cont$X0),]
inc_cont[1,1] <<- 0; inc_cont[1,2] <<- 0
colnames(inc_cont) <<- c("time", "incidence", "contacttraccap", "beta", "con/inc rat")
time10 <- inc_cont[,1][which(inc_cont[,2] < target)][2]
timesince <- inc_cont[,1][which(inc_cont[,2] < target)][2] - timecomp
return(c("Time1000" = timeequal, "TimeContactTracEqualInc" = timecomp,"TimeTargetReach" = time10, "RelTimetoTarget" = timesince))
}
#Specify the efficacy (as a fraction), ramp_rate, lockdown R0 and target incidence
#inc_cont will always output during the run - view for a more detailed overview of the model run.
contact_trac_run(0.8, 50, 0.9, 10)
#### Heat Maps ####
heatmap <- expand.grid(seq(1,50),seq(0.7,1, by = 0.01))
heatdata <- data.frame(matrix(nrow = nrow(heatmap), ncol = 6))
for (i in 1:nrow(heatmap)) {
heatdata[i,] <- c(heatmap[i,1],heatmap[i,2],contact_trac_run(0.8, heatmap[i,1], heatmap[i,2], 10))
print((i/nrow(heatmap)*100))
}
colnames(heatdata) <- c("ContRampUp", "Lock_R0", "Time1000", "TimeContactTracEqualInc", "TimeTargetReach", "RelTimetoTarget")
View(heatdata)
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_contour_filled()
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_contour()
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_density_2d()
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_contour(bins = 10)
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_contour(bins = 5)
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_contour(bins = 20)
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget)) +geom_contour_filled(bins = 10)
seq(0.7,1, by = 0.01)
ggplot(heatdata, aes(ContRampUp, Lock_R0, z = RelTimetoTarget,fill=..level..)) + stat_contour(geom='polygon')
View(heatmap)
View(inc_cont)
View(heatdata)
